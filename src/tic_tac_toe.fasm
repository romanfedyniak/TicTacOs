format binary as "bin"
    use16               ; 16-bit mode
    org 7c00h           ; offset

VGA_OFFSET = 0xA000

WIDTH = 320
HEIGHT = 200

GRID_SIZE = 150
GRID_X = WIDTH / 2 - GRID_SIZE / 2
GRID_Y = HEIGHT / 2 - GRID_SIZE / 2
GRID_LINE_THICKNESS = 4
GRID_CELL_SIZE = GRID_SIZE / 3 - ((GRID_SIZE / 3 / 10) * 3) ; GRID_SIZE / 3 * 0.7
X_THICKNESS = 7

BLACK = 00h
WHITE = 0Fh

macro draw_O x, y, radius, thickness
{
    push x
    push y
    push radius
    push thickness
    call 0000h:_draw_O
}

boot:
    ; load draw.bin to memory
    mov ax, 0000h
    mov es,ax
    mov bx, 500h
    mov ch, 0
    mov cl, 02h
    mov dh, 0
    mov al, 01h
    mov ah, 02h
    int 13h

    ; video mode 320Ñ…200 256 colors
    mov ah, 0h
    mov al, 13h
    int 10h

    mov dword [0x0070], draw

    jmp $

draw:
    pusha

    mov ax, 0x0000
    mov ds, ax
    mov ax, VGA_OFFSET
    mov es, ax

.clear:
    xor di, di
    mov cx, WIDTH * HEIGHT
    mov al, WHITE
    rep stosb

draw_board:
    mov al, BLACK
    mov dx, WIDTH * GRID_LINE_THICKNESS
.horizontal_lines:
    mov cx, GRID_SIZE
    mov di, GRID_X + WIDTH * (GRID_SIZE / 3 - GRID_LINE_THICKNESS / 2 + GRID_Y)
    sub di, dx
    rep stosb

    mov cx, GRID_SIZE
    mov di, GRID_X + WIDTH * (GRID_SIZE / 3 * 2 - GRID_LINE_THICKNESS / 2 + GRID_Y)
    sub di, dx
    rep stosb

    sub dx, WIDTH
    jnz .horizontal_lines

    mov dx, GRID_SIZE * WIDTH
.vertical_lines:
    mov cx, GRID_LINE_THICKNESS
    mov di, (GRID_SIZE / 3 - GRID_LINE_THICKNESS / 2 + GRID_X) + WIDTH * GRID_Y
    add di, dx
    rep stosb

    mov cx, GRID_LINE_THICKNESS
    mov di, (GRID_SIZE / 3 * 2 - GRID_LINE_THICKNESS / 2 + GRID_X) + WIDTH * GRID_Y
    add di, dx
    rep stosb

    sub dx, WIDTH
    jnz .vertical_lines

    draw_O 10, 100, 20, 5

    mov bx, 10
    mov cx, 50
    call draw_X
.end:
    popa
    iret


draw_X:
    ; al - color
    ; bx - x
    ; cx - y
    imul cx, WIDTH
    add bx, cx
    mov di, bx
    add di, -WIDTH ; compensation
    mov dx, GRID_CELL_SIZE * WIDTH + GRID_CELL_SIZE
.loop1:
    mov cx, X_THICKNESS
    push di
    add di, dx
    rep stosb
    pop di
    sub dx, WIDTH + 1
    jnz .loop1

    mov dx, GRID_CELL_SIZE * WIDTH - GRID_CELL_SIZE
    mov di, bx
    add di, GRID_CELL_SIZE - WIDTH
.loop2:
    mov cx, X_THICKNESS
    push di
    add di, dx
    rep stosb
    pop di
    sub dx, WIDTH - 1
    jnz .loop2
.end:
    ret


times 510 - ($-$$) db 0
dw 0xAA55

org 500h

_draw_O:
    ; al - color
    ; stack: x, y, radius, thickness
    ; x equ bp+12
    ; y equ bp+10
    ; radius equ bp+8
    ; thickness equ bp+6
    virtual at bp
        offset dp ?
        thickness dw ?
        radius dw ?
        y dw ?
        x dw ?
    end virtual

    push bp
    mov bp, sp
    
    mov bx, [radius]
    add [x], bx
    add [y], bx
    mov [yi], 0
    mov [err_o], 1
    sub [err_o], bx
    mov [xi], bx
    mov bx, [thickness]
    sub [xi], bx
    mov bx, [xi]
    mov [err_i], 1
    sub [err_i], bx
 
.loop:
    ; radius >= yi
    mov bx, [radius]
    cmp bx, [yi]
    jnge .end

    mov cx, [x]
    add cx, [xi]
    mov bx, [x]
    add bx, [radius]
    mov dx, [y]
    add dx, [yi]
    call x_line

    mov dx, [y]
    sub dx, [yi]
    call x_line

    mov cx, [x]
    sub cx, [radius]
    mov bx, [x]
    sub bx, [xi]
    call x_line

    mov dx, [y]
    add dx, [yi]
    call x_line

    mov cx, [x]
    sub cx, [yi]
    mov dx, [y]
    add dx, [xi]
    mov bx, [y]
    add bx, [radius]
    call y_line

    mov cx, [x]
    add cx, [yi]
    call y_line

    mov dx, [y]
    sub dx, [radius]
    mov bx, [y]
    sub bx, [xi]
    call y_line

    mov cx, [x]
    sub cx, [yi]
    call y_line

    inc word [yi]
.condition1:
    ; err_o < 0
    cmp [err_o], 0
    jnl .else1

    ; err_o += 2 * yi + 1
    imul bx, [yi], 2
    add bx, 1
    add [err_o], bx
    jmp .condition2
.else1:
    sub word [radius], 1
    ; err_o += 2 * (yi - radius + 1)
    mov bx, [yi]
    sub bx, [radius]
    add bx, 1
    imul bx, 2
    add [err_o], bx
.condition2:
    ; yi > radius - thickness
    mov bx, [radius]
    sub bx, [thickness]
    cmp [yi], bx
    jng .else2
    
    mov bx, [yi]
    mov [xi], bx
    jmp .loop
.else2:
.condition3:
    ; err_i < 0
    cmp [err_i], 0
    jnl .else3
    
    ; err_i += 2 * yi + 1
    imul bx, [yi], 2
    add bx, 1
    add [err_i], bx
    jmp .loop
.else3:
    sub [xi], 1
    ; err_i += 2 * (yi - xi + 1)
    mov bx, [yi]
    sub bx, [xi]
    add bx, 1
    imul bx, 2
    add [err_i], bx
    jmp .loop
.end:
    leave
    retf 4*2 ; delete param from stack

x_line:
    ; al - color
    ; cx - x1
    ; bx - x2
    ; dx - y
    push cx
    mov ah, 0Ch
.loop:
    cmp cx, bx
    jnle .end
    int 10h
    add cx, 1
    jmp .loop
.end:
    pop cx
    ret

y_line:
    ; al - color
    ; cx - x
    ; dx - y1
    ; bx - y2
    push dx
    mov ah, 0Ch
.loop:
    cmp dx, bx
    jnle .end
    int 10h
    add dx, 1
    jmp .loop
.end:
    pop dx
    ret

xi dw 0
err_o dw 0
err_i dw 0
yi dw 0

times 1024 - ($-$$) db 0
